import { Signer } from '@ethersproject/abstract-signer';
import { SignerWithAddress } from '@nomiclabs/hardhat-ethers/signers';

import { expect } from 'chai';
import { BigNumber } from 'ethers';
import { MockContract } from 'ethereum-waffle';
import { ethers, waffle } from 'hardhat';

import {
  AaveV3YieldSourceHarness,
  AaveV3YieldSourceHarness__factory,
  ERC20Mintable,
} from '../types';

import IAToken from '../abis/IAToken.json';
import IRewardsController from '../abis/IRewardsController.json';
import IPool from '../abis/IPool.json';
import IPoolAddressesProvider from '../abis/IPoolAddressesProvider.json';
import IPoolAddressesProviderRegistry from '../abis/IPoolAddressesProviderRegistry.json';
import SafeERC20Wrapper from '../abis/SafeERC20Wrapper.json';

const { constants, getContractFactory, getSigners, utils } = ethers;
const { AddressZero, MaxUint256 } = constants;
const { parseEther: toWei, parseUnits } = utils;

const DECIMALS = 6;
const REFERRAL_CODE = 188;

describe('AaveV3YieldSource', () => {
  let contractsOwner: Signer;
  let yieldSourceOwner: SignerWithAddress;
  let wallet2: SignerWithAddress;
  let attacker: SignerWithAddress;

  let aToken: MockContract;
  let rewardsController: MockContract;
  let pool: MockContract;
  let poolAddressesProvider: MockContract;
  let poolAddressesProviderRegistry: MockContract;

  let aaveV3YieldSource: AaveV3YieldSourceHarness;

  let erc20Token: MockContract;
  let usdcToken: ERC20Mintable;

  let constructorTest = false;

  const deployAaveV3YieldSource = async (
    aTokenAddress: string,
    rewardsControllerAddress: string,
    poolAddressesProviderRegistryAddress: string,
    decimals: number,
    owner: string,
  ): Promise<AaveV3YieldSourceHarness> => {
    const AaveV3YieldSource = (await ethers.getContractFactory(
      'AaveV3YieldSourceHarness',
    )) as AaveV3YieldSourceHarness__factory;

    return await AaveV3YieldSource.deploy(
      aTokenAddress,
      rewardsControllerAddress,
      poolAddressesProviderRegistryAddress,
      'PoolTogether aUSDC Yield',
      'PTaUSDCY',
      decimals,
      owner,
    );
  };

  const supplyTokenTo = async (
    user: SignerWithAddress,
    amount: BigNumber,
    aTokenTotalSupplyBefore: BigNumber,
    aTokenTotalSupplyAfter: BigNumber,
  ) => {
    const tokenAddress = await aaveV3YieldSource.depositToken();
    const userAddress = user.address;

    await usdcToken.mint(userAddress, amount);
    await usdcToken.connect(user).approve(aaveV3YieldSource.address, MaxUint256);

    await aToken.mock.balanceOf
      .withArgs(aaveV3YieldSource.address)
      .returns(aTokenTotalSupplyBefore);

    const shares = await aaveV3YieldSource.tokenToShares(amount);
    const supplyAmount = await aaveV3YieldSource.sharesToToken(shares);

    await pool.mock.supply
      .withArgs(tokenAddress, supplyAmount, aaveV3YieldSource.address, REFERRAL_CODE)
      .returns();

    await aaveV3YieldSource.connect(user).supplyTokenTo(supplyAmount, userAddress);

    await aToken.mock.balanceOf.withArgs(aaveV3YieldSource.address).returns(aTokenTotalSupplyAfter);
  };

  const sharesToToken = async (shares: BigNumber, yieldSourceTotalSupply: BigNumber) => {
    const totalShares = await aaveV3YieldSource.callStatic.totalSupply();

    // tokens = (shares * yieldSourceBalanceOfAToken) / totalSupply
    return shares.mul(yieldSourceTotalSupply).div(totalShares);
  };

  beforeEach(async () => {
    const { deployMockContract } = waffle;

    [contractsOwner, yieldSourceOwner, wallet2, attacker] = await getSigners();

    const ERC20MintableContract = await getContractFactory('ERC20Mintable', contractsOwner);

    erc20Token = await deployMockContract(contractsOwner, SafeERC20Wrapper);

    usdcToken = (await ERC20MintableContract.deploy('USD Coin', 'USDC', 6)) as ERC20Mintable;

    aToken = await deployMockContract(contractsOwner, IAToken);
    await aToken.mock.UNDERLYING_ASSET_ADDRESS.returns(usdcToken.address);

    pool = await deployMockContract(contractsOwner, IPool);
    await pool.supply.returns();

    rewardsController = await deployMockContract(contractsOwner, IRewardsController);

    poolAddressesProvider = await deployMockContract(contractsOwner, IPoolAddressesProvider);

    poolAddressesProviderRegistry = await deployMockContract(
      contractsOwner,
      IPoolAddressesProviderRegistry,
    );

    await poolAddressesProvider.mock.getPool.returns(pool.address);
    await poolAddressesProviderRegistry.mock.getAddressesProvidersList.returns([
      poolAddressesProvider.address,
    ]);

    if (!constructorTest) {
      aaveV3YieldSource = await deployAaveV3YieldSource(
        aToken.address,
        rewardsController.address,
        poolAddressesProviderRegistry.address,
        DECIMALS,
        yieldSourceOwner.address,
      );
    }
  });

  describe('constructor()', () => {
    beforeEach(() => {
      constructorTest = true;
    });

    afterEach(() => {
      constructorTest = false;
    });

    it('should deploy a new AaveV3YieldSource', async () => {
      const aaveV3YieldSource = await deployAaveV3YieldSource(
        aToken.address,
        rewardsController.address,
        poolAddressesProviderRegistry.address,
        DECIMALS,
        yieldSourceOwner.address,
      );

      await expect(aaveV3YieldSource.deployTransaction)
        .to.emit(aaveV3YieldSource, 'AaveV3YieldSourceInitialized')
        .withArgs(
          aToken.address,
          rewardsController.address,
          poolAddressesProviderRegistry.address,
          'PoolTogether aUSDC Yield',
          'PTaUSDCY',
          DECIMALS,
          yieldSourceOwner.address,
        );
    });

    it('should fail if aToken is address zero', async () => {
      await expect(
        deployAaveV3YieldSource(
          AddressZero,
          rewardsController.address,
          poolAddressesProviderRegistry.address,
          DECIMALS,
          yieldSourceOwner.address,
        ),
      ).to.be.revertedWith('AaveV3YS/aToken-not-zero-address');
    });

    it('should fail if rewardsController is address zero', async () => {
      await expect(
        deployAaveV3YieldSource(
          aToken.address,
          AddressZero,
          poolAddressesProviderRegistry.address,
          DECIMALS,
          yieldSourceOwner.address,
        ),
      ).to.be.revertedWith('AaveV3YS/RC-not-zero-address');
    });

    it('should fail if poolAddressesProviderRegistry is address zero', async () => {
      await expect(
        deployAaveV3YieldSource(
          aToken.address,
          rewardsController.address,
          AddressZero,
          DECIMALS,
          yieldSourceOwner.address,
        ),
      ).to.be.revertedWith('AaveV3YS/PR-not-zero-address');
    });

    it('should fail if owner is address zero', async () => {
      await expect(
        deployAaveV3YieldSource(
          aToken.address,
          rewardsController.address,
          poolAddressesProviderRegistry.address,
          DECIMALS,
          AddressZero,
        ),
      ).to.be.revertedWith('AaveV3YS/owner-not-zero-address');
    });

    it('should fail if token decimal is not greater than 0', async () => {
      await expect(
        deployAaveV3YieldSource(
          aToken.address,
          rewardsController.address,
          poolAddressesProviderRegistry.address,
          0,
          yieldSourceOwner.address,
        ),
      ).to.be.revertedWith('AaveV3YS/decimals-gt-zero');
    });
  });

  describe('decimals()', () => {
    it('should return the ERC20 token decimals number', async () => {
      expect(await aaveV3YieldSource.decimals()).to.equal(DECIMALS);
    });
  });

  describe('depositToken()', () => {
    it('should return the underlying token', async () => {
      expect(await aaveV3YieldSource.depositToken()).to.equal(usdcToken.address);
    });
  });

  describe('balanceOfToken()', () => {
    it('should return user balance', async () => {
      const firstAmount = toWei('100');
      const yieldSourceTotalSupply = firstAmount.mul(2);

      await supplyTokenTo(yieldSourceOwner, firstAmount, toWei('0'), firstAmount);
      await supplyTokenTo(yieldSourceOwner, firstAmount, firstAmount, yieldSourceTotalSupply);

      await aToken.mock.balanceOf
        .withArgs(aaveV3YieldSource.address)
        .returns(yieldSourceTotalSupply);

      const shares = await aaveV3YieldSource.callStatic.balanceOf(yieldSourceOwner.address);
      const tokens = await sharesToToken(shares, yieldSourceTotalSupply);

      expect(await aaveV3YieldSource.callStatic.balanceOfToken(yieldSourceOwner.address)).to.equal(
        tokens,
      );
    });
  });

  describe('_tokenToShares()', () => {
    it('should return shares amount', async () => {
      await aaveV3YieldSource.mint(yieldSourceOwner.address, toWei('100'));
      await aaveV3YieldSource.mint(wallet2.address, toWei('100'));
      await aToken.mock.balanceOf.withArgs(aaveV3YieldSource.address).returns(toWei('1000'));

      expect(await aaveV3YieldSource.tokenToShares(toWei('10'))).to.equal(toWei('2'));
    });

    it('should return 0 if tokens param is 0', async () => {
      expect(await aaveV3YieldSource.tokenToShares(toWei('0'))).to.equal(toWei('0'));
    });

    it('should return tokens if totalSupply is 0', async () => {
      expect(await aaveV3YieldSource.tokenToShares(toWei('100'))).to.equal(toWei('100'));
    });

    it('should return shares even if aToken total supply is very small', async () => {
      await aaveV3YieldSource.mint(yieldSourceOwner.address, toWei('1'));
      await aToken.mock.balanceOf.withArgs(aaveV3YieldSource.address).returns(toWei('0.000005'));

      expect(await aaveV3YieldSource.tokenToShares(toWei('0.000005'))).to.equal(toWei('1'));
    });

    it('should return shares even if aToken total supply increases', async () => {
      await aaveV3YieldSource.mint(yieldSourceOwner.address, toWei('100'));
      await aaveV3YieldSource.mint(wallet2.address, toWei('100'));
      await aToken.mock.balanceOf.withArgs(aaveV3YieldSource.address).returns(toWei('100'));

      expect(await aaveV3YieldSource.tokenToShares(toWei('1'))).to.equal(toWei('2'));

      await aToken.mock.balanceOf
        .withArgs(aaveV3YieldSource.address)
        .returns(parseUnits('100', 36));

      expect(await aaveV3YieldSource.tokenToShares(toWei('1'))).to.equal(2);
    });

    it('should fail to return shares if aToken total supply increases too much', async () => {
      await aaveV3YieldSource.mint(yieldSourceOwner.address, toWei('100'));
      await aaveV3YieldSource.mint(wallet2.address, toWei('100'));
      await aToken.mock.balanceOf.withArgs(aaveV3YieldSource.address).returns(toWei('100'));

      expect(await aaveV3YieldSource.tokenToShares(toWei('1'))).to.equal(toWei('2'));

      await aToken.mock.balanceOf
        .withArgs(aaveV3YieldSource.address)
        .returns(parseUnits('100', 37));

      await expect(aaveV3YieldSource.supplyTokenTo(toWei('1'), wallet2.address)).to.be.revertedWith(
        'AaveV3YS/shares-gt-zero',
      );
    });
  });

  describe('PoolTogether vulnerabilities', () => {

    //For this test I assume USDC has 18 decimals rather than 6. I'm pretty sure it works either way; just making it easier on myself.
    it.only('allows easy pool draining if an early depositor ramps up the share price, then rug pulls', async () => {
      const USDC_DECIMALS = 18;
      console.log('Current vault shares: ', (await aaveV3YieldSource.totalSupply()).toString())
      console.log('Current vault token balance: ', (await usdcToken.balanceOf(aaveV3YieldSource.address)).toString())
      //Mint 1 share to attacker for 1 wei
      const ATTACKER_STARTING_BAL = BigNumber.from(10).pow(USDC_DECIMALS).mul(10000) moose
      console.log('335')
      await usdcToken.connect(attacker).approve(aaveV3YieldSource.address, MaxUint256)
      console.log('336');
      await usdcToken.mint(attacker.address, ATTACKER_STARTING_BAL)  //Attacker starts with 10,000 USDC (well, not usdc due to decimals, but most other coins)
      console.log('339')
      await aaveV3YieldSource.connect(attacker).supplyTokenTo(1, attacker.address);

      console.log('342')

      //Attacker transfers in 1000 tokens to ramp share value up to 10^21 tokens / share
      await usdcToken.connect(attacker).transfer(aaveV3YieldSource.address, BigNumber.from(10).pow(USDC_DECIMALS).mul(1000));

      //Now some poor sap deposits 100,000 USDC
      const USER_STARTING_BAL = BigNumber.from(10).pow(USDC_DECIMALS).mul(100000)
      await usdcToken.mint(wallet2.address, USER_STARTING_BAL)
      await usdcToken.connect(wallet2).approve(aaveV3YieldSource.address, MaxUint256)
      await aaveV3YieldSource.connect(wallet2).supplyTokenTo(BigNumber.from(10).pow(USDC_DECIMALS), wallet2.address)

      console.log('New vault shares: ', (await aaveV3YieldSource.totalSupply()).toString())
      console.log('New vault token balance: ', (await usdcToken.balanceOf(aaveV3YieldSource.address)).toString())
      console.log('Tokens / share: ', (await aaveV3YieldSource.sharesToToken(1).toString()))

      //Now at this point I need to call withdraw over and over. If a share is worth 1000 tokens, I redeem 1999 tokens and burn 1 share, then deposit it back and repeat.

      expect(await aaveV3YieldSource.tokenToShares(toWei('1'))).to.equal(0);
      expect(await aaveV3YieldSource.sharesToToken(toWei('1'))).to.equal(BigNumber.from(10).pow(21));

      //Ramp up share price to an arbitrarily large value (let's say 10^21 tokens / share)

      // await aToken.mock.balanceOf
      //   .withArgs(aaveV3YieldSource.address)
      //   .returns(parseUnits('2', 23));

      //Once others have deposited, rug by exploiting incorrect round-down over and over again. This would probably be done through a smart contract in reality.
    })

    it('allows difficult pool draining whenever tokens / share gets too large', async () => {
      //Set up contract with a reasonable amount of tokens (let's say 100,000), and each share is worth 100 tokens

      //Now exploiter withdraws, exploiting incorrect round-down over and over again. This would probably be done by a smart contract in reality.
    })
  })

  describe('_sharesToToken()', () => {
    it('should return tokens amount', async () => {
      await aaveV3YieldSource.mint(yieldSourceOwner.address, toWei('100'));
      await aaveV3YieldSource.mint(wallet2.address, toWei('100'));
      await aToken.mock.balanceOf.withArgs(aaveV3YieldSource.address).returns(toWei('1000'));

      expect(await aaveV3YieldSource.sharesToToken(toWei('2'))).to.equal(toWei('10'));
    });

    it('should return shares if totalSupply is 0', async () => {
      expect(await aaveV3YieldSource.sharesToToken(toWei('100'))).to.equal(toWei('100'));
    });

    it('should return tokens even if shares are very small', async () => {
      await aaveV3YieldSource.mint(yieldSourceOwner.address, toWei('0.000000000000000005'));
      await aToken.mock.balanceOf.withArgs(aaveV3YieldSource.address).returns(toWei('100'));

      expect(await aaveV3YieldSource.sharesToToken(toWei('0.000000000000000005'))).to.equal(
        toWei('100'),
      );
    });

    it('should return tokens even if aToken total supply increases', async () => {
      await aaveV3YieldSource.mint(yieldSourceOwner.address, toWei('100'));
      await aaveV3YieldSource.mint(wallet2.address, toWei('100'));
      await aToken.mock.balanceOf.withArgs(aaveV3YieldSource.address).returns(toWei('100'));

      expect(await aaveV3YieldSource.sharesToToken(toWei('2'))).to.equal(toWei('1'));

      await aToken.mock.balanceOf
        .withArgs(aaveV3YieldSource.address)
        .returns(parseUnits('100', 36));

      expect(await aaveV3YieldSource.sharesToToken(2)).to.equal(toWei('1'));
    });
  });

  describe('supplyTokenTo()', () => {
    let amount: BigNumber;
    let tokenAddress: any;

    beforeEach(async () => {
      amount = toWei('100');
      tokenAddress = await aaveV3YieldSource.depositToken();
    });

    it('should supply assets if totalSupply is 0', async () => {
      await supplyTokenTo(yieldSourceOwner, amount, toWei('0'), amount);
      expect(await aaveV3YieldSource.totalSupply()).to.equal(amount);
    });

    it('should supply assets if totalSupply is not 0', async () => {
      await supplyTokenTo(yieldSourceOwner, amount, toWei('0'), amount);
      await supplyTokenTo(wallet2, amount, amount, amount.mul(2));
      expect(await aaveV3YieldSource.totalSupply()).to.equal(amount.mul(2));
    });

    it('should fail to manipulate shares price', async () => {
      const attackAmount = BigNumber.from(10000000);
      const aTokenAmount = toWei('1000');

      await supplyTokenTo(attacker, attackAmount, toWei('0'), attackAmount);

      // Attacker sends 1000 aTokens directly to the contract to manipulate shares price
      await supplyTokenTo(
        wallet2,
        amount,
        attackAmount.add(aTokenAmount),
        amount.add(attackAmount).add(aTokenAmount),
      );

      // We account for a small loss in precision due to the attack
      expect(await aaveV3YieldSource.callStatic.balanceOfToken(attacker.address)).to.be.gte(
        attackAmount.add(aTokenAmount),
      );

      expect(await aaveV3YieldSource.callStatic.balanceOfToken(wallet2.address)).to.be.gte(
        amount.sub(toWei('0.0001')),
      );
    });

    it('should revert on error', async () => {
      await pool.mock.deposit
        .withArgs(tokenAddress, amount, aaveV3YieldSource.address, REFERRAL_CODE)
        .reverts();

      await expect(
        aaveV3YieldSource.supplyTokenTo(amount, aaveV3YieldSource.address),
      ).to.be.revertedWith('');
    });
  });

  describe('redeemToken()', () => {
    let yieldSourceOwnerBalance: BigNumber;
    let redeemAmount: BigNumber;

    beforeEach(() => {
      yieldSourceOwnerBalance = toWei('300');
      redeemAmount = toWei('100');
    });

    it('should redeem assets', async () => {
      await supplyTokenTo(
        yieldSourceOwner,
        yieldSourceOwnerBalance,
        toWei('0'),
        yieldSourceOwnerBalance,
      );

      await aToken.mock.balanceOf
        .withArgs(aaveV3YieldSource.address)
        .returns(yieldSourceOwnerBalance);

      await pool.mock.withdraw
        .withArgs(usdcToken.address, redeemAmount, aaveV3YieldSource.address)
        .returns(redeemAmount);

      await aaveV3YieldSource.connect(yieldSourceOwner).redeemToken(redeemAmount);

      expect(await aaveV3YieldSource.callStatic.balanceOf(yieldSourceOwner.address)).to.equal(
        yieldSourceOwnerBalance.sub(redeemAmount),
      );
    });

    it('should not be able to redeem assets if balance is 0', async () => {
      await expect(
        aaveV3YieldSource.connect(yieldSourceOwner).redeemToken(redeemAmount),
      ).to.be.revertedWith('ERC20: burn amount exceeds balance');
    });

    it('should fail to redeem if amount is greater than balance', async () => {
      const yieldSourceOwnerLowBalance = toWei('10');

      await aaveV3YieldSource.mint(yieldSourceOwner.address, yieldSourceOwnerLowBalance);

      await aToken.mock.balanceOf
        .withArgs(aaveV3YieldSource.address)
        .returns(yieldSourceOwnerLowBalance);

      await pool.mock.withdraw
        .withArgs(usdcToken.address, redeemAmount, aaveV3YieldSource.address)
        .returns(redeemAmount);

      await expect(
        aaveV3YieldSource.connect(yieldSourceOwner).redeemToken(redeemAmount),
      ).to.be.revertedWith('ERC20: burn amount exceeds balance');
    });
  });

  describe('claimRewards()', () => {
    const claimAmount = toWei('100');

    beforeEach(async () => {
      await rewardsController.mock.claimAllRewards
        .withArgs([aToken.address], wallet2.address)
        .returns([erc20Token.address], [claimAmount]);
    });

    it('should claimRewards if yieldSourceOwner', async () => {
      await expect(aaveV3YieldSource.connect(yieldSourceOwner).claimRewards(wallet2.address))
        .to.emit(aaveV3YieldSource, 'Claimed')
        .withArgs(yieldSourceOwner.address, wallet2.address, [erc20Token.address], [claimAmount]);
    });

    it('should claimRewards if assetManager', async () => {
      await aaveV3YieldSource.connect(yieldSourceOwner).setManager(wallet2.address);

      await expect(aaveV3YieldSource.connect(wallet2).claimRewards(wallet2.address))
        .to.emit(aaveV3YieldSource, 'Claimed')
        .withArgs(wallet2.address, wallet2.address, [erc20Token.address], [claimAmount]);
    });

    it('should fail to claimRewards if recipient is address zero', async () => {
      await expect(
        aaveV3YieldSource.connect(yieldSourceOwner).claimRewards(AddressZero),
      ).to.be.revertedWith('AaveV3YS/payee-not-zero-address');
    });

    it('should fail to claimRewards if not yieldSourceOwner or assetManager', async () => {
      await expect(
        aaveV3YieldSource.connect(wallet2).claimRewards(wallet2.address),
      ).to.be.revertedWith('Manageable/caller-not-manager-or-owner');
    });
  });

  describe('increaseERC20Allowance()', () => {
    it('should increase allowance if yieldSourceOwner', async () => {
      const approveAmount = toWei('10');

      usdcToken.mint(aaveV3YieldSource.address, approveAmount);

      await aaveV3YieldSource
        .connect(yieldSourceOwner)
        .increaseERC20Allowance(usdcToken.address, yieldSourceOwner.address, approveAmount);

      usdcToken
        .connect(wallet2)
        .transferFrom(aaveV3YieldSource.address, wallet2.address, approveAmount);
    });

    it('should increase allowance of the underlying asset deposited into the Aave pool', async () => {
      await aaveV3YieldSource
        .connect(yieldSourceOwner)
        .decreaseERC20Allowance(usdcToken.address, pool.address, MaxUint256);

      expect(await usdcToken.allowance(aaveV3YieldSource.address, pool.address)).to.equal(
        toWei('0'),
      );

      await aaveV3YieldSource
        .connect(yieldSourceOwner)
        .increaseERC20Allowance(usdcToken.address, pool.address, MaxUint256);

      expect(await usdcToken.allowance(aaveV3YieldSource.address, pool.address)).to.equal(
        MaxUint256,
      );
    });

    it('should increase allowance if assetManager', async () => {
      const approveAmount = toWei('10');

      await aaveV3YieldSource.connect(yieldSourceOwner).setManager(wallet2.address);

      usdcToken.mint(aaveV3YieldSource.address, approveAmount);

      await aaveV3YieldSource
        .connect(wallet2)
        .increaseERC20Allowance(usdcToken.address, wallet2.address, approveAmount);

      usdcToken
        .connect(wallet2)
        .transferFrom(aaveV3YieldSource.address, wallet2.address, approveAmount);
    });

    it('should not allow to increase allowance of aToken', async () => {
      await expect(
        aaveV3YieldSource
          .connect(yieldSourceOwner)
          .increaseERC20Allowance(aToken.address, wallet2.address, toWei('10')),
      ).to.be.revertedWith('AaveV3YS/forbid-aToken-change');
    });

    it('should fail to increase allowance if not yieldSourceOwner or assetManager', async () => {
      await expect(
        aaveV3YieldSource
          .connect(wallet2)
          .increaseERC20Allowance(usdcToken.address, yieldSourceOwner.address, toWei('10')),
      ).to.be.revertedWith('Manageable/caller-not-manager-or-owner');
    });
  });

  describe('decreaseERC20Allowance()', () => {
    beforeEach(async () => {
      await aaveV3YieldSource
        .connect(yieldSourceOwner)
        .increaseERC20Allowance(usdcToken.address, wallet2.address, MaxUint256);
    });

    it('should decrease allowance if yieldSourceOwner', async () => {
      usdcToken.mint(aaveV3YieldSource.address, MaxUint256);

      await aaveV3YieldSource
        .connect(yieldSourceOwner)
        .decreaseERC20Allowance(usdcToken.address, wallet2.address, MaxUint256);

      await expect(
        usdcToken
          .connect(wallet2)
          .transferFrom(aaveV3YieldSource.address, wallet2.address, MaxUint256),
      ).to.be.revertedWith('ERC20: insufficient allowance');
    });

    it('should decrease allowance if assetManager', async () => {
      await aaveV3YieldSource.connect(yieldSourceOwner).setManager(wallet2.address);

      usdcToken.mint(aaveV3YieldSource.address, MaxUint256);

      await aaveV3YieldSource
        .connect(wallet2)
        .decreaseERC20Allowance(usdcToken.address, wallet2.address, MaxUint256);

      await expect(
        usdcToken
          .connect(wallet2)
          .transferFrom(aaveV3YieldSource.address, wallet2.address, MaxUint256),
      ).to.be.revertedWith('ERC20: insufficient allowance');
    });

    it('should not allow to decrease allowance of aToken', async () => {
      await expect(
        aaveV3YieldSource
          .connect(yieldSourceOwner)
          .decreaseERC20Allowance(aToken.address, wallet2.address, MaxUint256),
      ).to.be.revertedWith('AaveV3YS/forbid-aToken-change');
    });

    it('should fail to decrease allowance if not yieldSourceOwner or assetManager', async () => {
      await expect(
        aaveV3YieldSource
          .connect(wallet2)
          .decreaseERC20Allowance(usdcToken.address, yieldSourceOwner.address, MaxUint256),
      ).to.be.revertedWith('Manageable/caller-not-manager-or-owner');
    });
  });

  describe('transferERC20()', () => {
    it('should transferERC20 if yieldSourceOwner', async () => {
      const transferAmount = toWei('10');

      usdcToken.mint(aaveV3YieldSource.address, transferAmount);

      await aaveV3YieldSource
        .connect(yieldSourceOwner)
        .transferERC20(usdcToken.address, wallet2.address, transferAmount);
    });

    it('should transferERC20 if assetManager', async () => {
      const transferAmount = toWei('10');

      usdcToken.mint(aaveV3YieldSource.address, transferAmount);

      await aaveV3YieldSource.connect(yieldSourceOwner).setManager(wallet2.address);

      await aaveV3YieldSource
        .connect(wallet2)
        .transferERC20(usdcToken.address, yieldSourceOwner.address, transferAmount);
    });

    it('should not allow to transfer aToken', async () => {
      await expect(
        aaveV3YieldSource
          .connect(yieldSourceOwner)
          .transferERC20(aToken.address, wallet2.address, toWei('10')),
      ).to.be.revertedWith('AaveV3YS/forbid-aToken-change');
    });

    it('should fail to transferERC20 if not yieldSourceOwner or assetManager', async () => {
      await expect(
        aaveV3YieldSource
          .connect(wallet2)
          .transferERC20(usdcToken.address, yieldSourceOwner.address, toWei('10')),
      ).to.be.revertedWith('Manageable/caller-not-manager-or-owner');
    });
  });

  describe('_pool()', () => {
    it('should return Aave Pool address', async () => {
      expect(await aaveV3YieldSource.pool()).to.equal(pool.address);
    });
  });
});
